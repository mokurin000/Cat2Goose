import yaml

from sys import argv, stderr
from collections.abc import Iterable
from functools import partial
from importlib.metadata import version

DEFAULT_OUTBOUNDS = ["direct", "block"]


class GooseRule:
    def __init__(self, rule_type: str, content: str, target_group: str):
        self.rule_type = rule_type
        self.content = content
        self.target_group = target_group


def translate(
    group_set: set[str], rename_map: dict[str, str], rule: str
) -> GooseRule | None:
    if rule.startswith("MATCH"):
        return None

    try:
        rule_type, content, group = rule.split(",")[:3]
    except ValueError:
        print(f"failed to parse {rule}", file=stderr)
        raise

    group_lower = group.lower()

    if "direct" in group_lower:
        group = "direct"
    elif "proxy" in group_lower or "proxies" in group_lower:
        group = "proxy"
    elif "reject" in group_lower:
        group = "block"

    group = rename_map.get(group, group)
    group_set.add(group)

    match rule_type.upper():
        case "DOMAIN":
            return GooseRule(
                rule_type="domain", content=f"full:{content}", target_group=group
            )
        case "DOMAIN-KEYWORD":
            return GooseRule(
                rule_type="domain", content=f"keyword:{content}", target_group=group
            )
        case "DOMAIN-SUFFIX":
            return GooseRule(
                rule_type="domain", content=f"suffix:{content}", target_group=group
            )
        case "IP-CIDR":
            return GooseRule(rule_type="dip", content=content, target_group=group)
        case "IP-CIDR6":
            return GooseRule(
                rule_type="dip", content=content.__repr__(), target_group=group
            )
        case "GEOIP":
            content = f"geoip:{content.lower()}"
            return GooseRule(rule_type="dip", content=content, target_group=group)

        # Impossible to goose
        case "PROCESS-NAME":
            return None
        case _:
            print(f"warn: unsupported schema {rule_type}", file=stderr)
            print(f"full line: {rule}", file=stderr)
            return None


def main():
    yaml_path = argv[1]
    rename_map = {}

    with open(yaml_path, "r", encoding="utf-8") as f:
        data = yaml.load(f, Loader=yaml.Loader)

    for arg in argv[2:]:
        origin, new = arg.split(":")
        rename_map[origin] = new

    groups = set()

    if "rules" not in data:
        print("'rules' not found!", file=stderr)
        return

    goose_rules: Iterable[GooseRule] = filter(
        lambda rule: rule is not None,
        map(partial(translate, groups, rename_map), data["rules"]),
    )
    goose_groups: dict[tuple[str, str], set[str]] = {}
    for goose_rule in goose_rules:
        group_key = (goose_rule.rule_type, goose_rule.target_group)
        goose_groups[group_key] = goose_groups.get(group_key, set())
        goose_groups[group_key].add(goose_rule.content)

    groups = sorted(group for group in groups if group not in DEFAULT_OUTBOUNDS)

    package_name = __spec__.name
    package_version = version(package_name)
    print(f"# generated by {package_name} v{package_version}")
    if groups:
        groups = ", ".join(sorted(groups))
        print(f"# groups: {groups}")

    for (rule_type, target_group), contents in goose_groups.items():
        content = ", ".join(sorted(contents))
        print(f"{rule_type}({content}) -> {target_group}")


if __name__ == "__main__":
    main()
